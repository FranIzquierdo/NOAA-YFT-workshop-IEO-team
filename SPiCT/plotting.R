# Stochastic surplus Production model in Continuous-Time (SPiCT)
#    Copyright (C) 2015-2016  Martin W. Pedersen, mawp@dtu.dk, wpsgodd@gmail.com
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' @name get.mfrow
#' @title Get mfrow from the number of plots to be plotted
#' @param n Number of plots to be plotted.
#' @return Nothing
#' @export
get.mfrow <- function(n){
    ncol <- floor(sqrt(n))
    nrow <- ceiling(n/ncol)
    return(c(nrow, ncol))
}

#' @name add.manlines
#' @title Add lines to plot indicating result of management scenarios.
#' @param rep A result report as generated by running fit.spict.
#' @param par The name of the parameter to be plotted.
#' @param par2 If a second parameter should be used as explanatory variable instead of time.
#' @param index.shift Shift initial time point by this index.
#' @param plot.legend Logical; should the legend be plotted?
#' @param verbose Should detailed outputs be provided (default: TRUE).
#' @return Nothing
#' @export
add.manlines <- function(rep, par, par2=NULL, index.shift=0, plot.legend=TRUE,
                         verbose = TRUE, ...){
    scenarios <- 1:length(rep$man)
    nman <- length(scenarios)
    errflag <- rep(FALSE,nman)
    for (i in 1:nman){
        rp <- rep$man[[scenarios[i]]]
        ip <- rp$inp
        manint <- ip$maninterval
        mandiff <- diff(manint)
        est <- get.par(par, rp, exp=TRUE)[,2]
        dtcp <- ip$dtcp
        if(par == 'logCpred'){
            time <- rp$inp$timeCpred
            lastobs <- ip$lastCatchObs
            indlastobs <- which(time == lastobs)
        }else{
            time <- rp$inp$time
            lastobs <- ip$timerangeObs[2]
            indlastobs <- which(time == lastobs)
        }
        indmanstart <- which(time >= manint[1])
        ## manperiod
        if(par == 'logCpred'){
            if(mandiff < 1){
                errflag[i] <- TRUE
                mantime <- NULL
                manc <- NULL
            }else if(mandiff > 1){
                mantime <- seq(manint[1], manint[2], 1)
                mantime <- mantime[-length(mantime)]
                manc <- rep(est[indmanstart] / mandiff, length(mantime))
            }else{
                mantime <- manint[1]
                manc <- est[indmanstart]
            }
            ## aggregate seasonal catches in man
            if(any(dtcp[indmanstart] < 1)){
                alo <- annual(time[indmanstart], est[indmanstart]/dtcp[indmanstart], mean)
                mantime <- alo$anntime
                manc <- alo$annvec
            }
            ind <- which(time < manint[1])
            preind <- tail(which(dtcp[ind] == 1),1)
            ## aggregate seasonal catches before man
            if(any(dtcp[ind] < 1)){
                alo <- annual(time[ind], est[ind]/dtcp[ind], mean)
                time <- alo$anntime
                est <- alo$annvec
                ind <- which(time < manint[1])
                dtcp <- diff(unique(c(time,manint[1])))
                preind <- which.max(time[which(dtcp >= 1)])
            }
            premantime <- time[preind]
            premanc <- est[preind]
            x <- c(premantime,mantime)
            y <- c(premanc,manc)
        }else{
            maninds <- (indmanstart[1] - index.shift):tail(indmanstart,1)
            if (is.null(par2)){
                x <- time[maninds]
            } else {
                x <- get.par(par2, rp, exp=TRUE)[maninds, 2]
            }
            y <- est[maninds]
        }
        lines(x, y, col=man.cols()[i], lwd=1.5, ...)
        ## intermediate period
        intdiff <- manint[1] - lastobs
        if(intdiff > 0 && (par != 'logCpred' || (par == 'logCpred' && intdiff %% 1 == 0))){
            ind <- which(time >= lastobs & time < manint[1])
            if(par == 'logCpred'){
                if(intdiff %% 1 == 0){
                    intinds <- (ind[1] - index.shift):preind
                }
            }else{
                intinds <- (ind[1] - index.shift):maninds[1]
            }
            if (is.null(par2)){
                x <- time[intinds]
            } else {
                x <- get.par(par2, rp, exp=TRUE)[intinds, 2]
            }
            y <- est[intinds]
            lines(x, y, col=man.cols()[i], lwd=1.5, lty=3)
        }
    }
    ## legend
    nouse <- capture.output(nms <- rownames(sumspict.manage(rep, include.unc=FALSE, verbose=FALSE)$est))
    if (plot.legend){
        legend('topleft', legend=nms, lty=1, col=man.cols()[1:nman], bg='transparent', cex=0.8)
    }
    ## Note
    if(errflag && verbose) cat(paste0("The management period of scenario(s): ",
                                      paste0(names(rep$man)[errflag],collapse=", "),
                                      " is shorter than 1 year. Thus, the catch cannot be displayed correctly in the annual catch plot.\n"))
}


#' @name get.manlimits
#' @title Get limts of any parameter considering all spict objects in rep$man
#' @param rep A result report as generated by running fit.spict.
#' @param par The name of the parameter to be plotted.
#' @return plotting limits for all reps in rep$man
get.manlimits <- function(rep, par, CI = 0.95){
    scenarios <- 1:length(rep$man)
    nman <- length(scenarios)
    lims <- vector("list",nman)
    for (i in 1:nman){
        rp <- rep$man[[ scenarios[i] ]]
        if (par == 'time'){
            lims[[i]] <- range(c(rp$inp$time, tail(rp$inp$time, 1) + 0.5))
        }else{
            lims[[i]] <- get.par(par, rp, exp=TRUE)[, 2]
            if(par == "logCpred"){
                lims[[i]] <- lims[[i]] / c(diff(rp$inp$timeCpred), rp$inp$dtpredc)
            }

        }
    }
    return(range(unlist(lims)))
}

#' @name get.manmax
#' @title Get spict object in rep$man with longest time series
#' @param rep A result report as generated by running fit.spict.
#' @return rep in rep$man which hast the longest time series
get.manmax <- function(rep){
    scenarios <- 1:length(rep$man)
    nman <- length(scenarios)
    maxs <- vector("list",nman)
    for (i in 1:nman){
        ip <- rep$man[[ scenarios[i] ]]$inp
        maxs <- max(ip$ns)
    }
    repout <- rep$man[[which.max(maxs)[1]]]
    return(repout)
}


#' @name txt.stamp
#' @title Add spict version to plot
#' @param string Character string to stamp.
#' @param cex Stamp cex.
#' @param do.flag If NULL stamp will be added if not in a multi plot, i.e. mean(par()$mfrow) > 1
#' @return Nothing
#' @export
txt.stamp <- function(string = get.version(), cex=0.5, do.flag=NULL) {
    #if (string == 'undef'){
    #    string <- get.version()
    #}
    if (is.null(do.flag)){
        if (mean(par()$mfrow) > 1){
            do.flag <- FALSE
        } else {
            do.flag <- TRUE
        }
    }
    if (!is.null(string)){
        if (string != '' & !is.na(string) & do.flag){
            opar <- par(new = "TRUE", plt = c(0, 1, 0, 1), mfrow=c(1, 1), xpd=FALSE)
            on.exit(par(opar))
            plot(1, typ='n', xaxt='n', yaxt='n', xlab='', ylab='', bty='n') # Empty plot
            #opar <- par(yaxt = "s", xaxt = "s")
            on.exit(par(opar))
            plt <- par("plt")
            usr <- par("usr")
            xcoord <- usr[2] + (usr[2] - usr[1])/(plt[2] - plt[1]) * (1 - plt[2]) - 0.4 * strwidth("m")
            ycoord <- usr[3] - diff(usr[3:4])/diff(plt[3:4]) * (plt[3]) + 0.4 * strheight("m")
            if (par("xlog")){
                xcoord <- 10^(xcoord)
            }
            if (par("ylog")){
                ycoord <- 10^(ycoord)
            }
            text(xcoord, ycoord, string, adj = 1, cex=cex)
        }
    }
}


#' @name warning.stamp
#' @title Add warning sign to plot
#' @return Nothing
warning.stamp <- function(){
    opar <- par(yaxt = "s", xaxt = "s", xpd = NA)
    on.exit(par(opar))
    usr <- par("usr")
    xcoord <- usr[1]
    ycoord <- usr[4] + 0.035/diff(par()$fig[3:4]) * diff(usr[3:4])
    if (par("xlog")){
        xcoord <- 10^(xcoord)
    }
    if (par("ylog")){
        ycoord <- 10^(ycoord)
    }
    points(xcoord, ycoord, pch=24, bg='yellow', col='black', cex=2, lwd=1.5)
    text(xcoord, ycoord, '!', cex=0.8)
}


#' @name add.catchunit
#' @title Add catch unit to label
#' @param lab Base label
#' @param cu Catch unit as a character string
#' @return Label with added catch unit
add.catchunit <- function(lab, cu){
    cu <- as.character(cu)
    if (cu != ''){
        out <- eval(bquote(.(lab[[1]]) *',' ~ .(cu)))
    } else {
        out <- lab
    }
    return(out)
}


#' @name arrow.line
#' @title Draw a line with arrow heads.
#' @details Add to an existing plot a continuous line with arrow heads showing the direction between each data point
#' @param x X coordinates.
#' @param y Y coordinates.
#' @param length See documentation for arrows.
#' @param angle See documentation for arrows.
#' @param code See documentation for arrows.
#' @param col See documentation for arrows.
#' @param lty See documentation for arrows.
#' @param lwd See documentation for arrows.
#' @param ... See documentation for arrows.
#' @return Nothing, but an arrow line is added to the current plot.
arrow.line <- function(x, y, length = 0.25, angle = 30, code = 2, col = par("fg"), lty = par("lty"), lwd = par("lwd"), ...){
    n <- length(x)
    for (i in 2:n){
        arrows(x[i-1], y[i-1], x[i], y[i], length, angle, code, col, lty, lwd, ...)
    }
}


#' @name annual
#' @title Convert from quarterly (or other sub-annual) data to annual means, sums or a custom function.
#' @param intime A time vector corresponding to the values in vec.
#' @param vec The vector of values to convert to annual means
#' @param type If type='mean' then annual mean is calculated, if type='sum' then annual sum is calculated. If type is a function, that function is used.
#' @return A list containing the annual means and a corresponding time vector.
#' @export
annual <- function(intime, vec, type='mean'){
    anntime <- intime[which(intime %% 1 == 0)]
    nanntime <- length(anntime)
    nstepvec <- rep(0, nanntime)
    floortime <- floor(intime)
    for (i in 1:nanntime){
        nstepvec[i] <- sum(anntime[i]==floortime)
    }
    nsteps <- max(nstepvec)
    # Remove years that are not full
    anntime <- anntime[which(nstepvec==max(nstepvec))]
    nanntime <- length(anntime)
    annvec <- rep(0, nanntime)
    for (i in 1:nanntime){
        inds <- which(anntime[i]==floortime)
        if (is(type, "function")) {
            annvec[i] <- type(vec[inds])
        } else{
            if (type=='mean'){
                annvec[i] <- mean(vec[inds])
            }
            if (type=='sum'){
                annvec[i] <- sum(vec[inds])
            }
        }
    }
    return(list(anntime=anntime, annvec=annvec))
}


#' @name refpointci
#' @title Draw CI around a reference point using polygon
#' @param t Time vector.
#' @param ll Lower limit.
#' @param ul Upper limit.
#' @param cicol Colour of polygon
#' @return Spline design matrix.
refpointci <- function(t, ll, ul, cicol='ivory2'){
    tplus <- c(t[1]*0.8, t, tail(t, 1)*1.2)
    llplus <- c(ll[1], ll, tail(ll, 1))
    ulplus <- c(ul[1], ul, tail(ul, 1))
    polygon(c(tplus, rev(tplus)), c(llplus, rev(ulplus)), col=cicol, border=cicol)
}

#' @name make.rpellipse
#' @title Calculate confidence ellipsis for reference points.
#' @details Calculates the confidence ellipsis of logBmsy and logFmsy (last if multiple)
#' @param rep A result report as generated by running fit.spict.
#' @return A matrix with two columns containing the x and y coordinates of the ellipsis.
#' @importFrom ellipse ellipse
make.rpellipse <- function(rep){
    inds <- c(max(which(names(rep$value)=='logBmsy')), max(which(names(rep$value)=='logFmsy')))
    sds <- rep$sd[inds]
    cova <- ( rep$sd[ which(names(rep$value)=='logBmsyPluslogFmsy') ]^2 - sds[1]^2 - sds[2]^2 )/2
    covBF <- matrix( c( sds[1]^2, cova, cova, sds[2]^2 ),2,2,byrow=TRUE)
    corBF <- cov2cor(covBF)
    parBF <- rep$value[inds]
    return(ellipse::ellipse(corBF[1,2], scale=sqrt(diag(covBF)), centre=parBF, npoints=300))
}


#' @name season.cols
#' @title Load season colors.
#' @param modin Time vector modulo 1.
#' @return Vector containing season colors.
season.cols <- function(modin){
    # Make colors
    seasons <- colorRamp(c('blue', 'green', 'gold', 'red', 'blue'))
    ncols <- 13
    cols <- seasons(seq(0, 1, length=ncols))
    rgbcols <- rgb(cols[, 1]/255, cols[, 2]/255, cols[, 3]/255) # Color no 13 = color no 1, only use 1:12
    # Find colors corresponding to modin
    breaks <- seq(0, 1, length=ncols) # Monthly breaks
    ind <- cut(modin, breaks, right=FALSE, labels=FALSE)
    ind[is.na(ind)] <- 1
    return(rgbcols[ind])
}


#' @name true.col
#' @title Load color of true values from simulation.
#' @return Color vector
true.col <- function() rgb(1, 165/255, 0, alpha=0.7) # 'orange'


#' @name man.cols
#' @title Load color of management scenarios.
#' @return Color vector
man.cols <- function(){
    colvec <- c('darkmagenta','cyan3','darkgreen','coral1','black',
                'magenta','gold','green','cadetblue3',
                'chocolate3', 'darkolivegreen3','cyan','darkred')
    return(rep(colvec, 3))
}


#' @name plot.col
#' @title Plot model points colored depending on the quarter to which they belong.
#' @param time Time vector.
#' @param obs Observation vector (or residual vector).
#' @param obsx Second observation vector for use as independent variable instead of time.
#' @param pch Point character.
#' @param add If TRUE plot is added to the current plot.
#' @param typ Plot type.
#' @param do.line If TRUE draw a line between points.
#' @param add.legend If TRUE add legend containing information on quarters.
#' @param add.vline.at If not NULL will draw a vertical line at the given time point.
#' @param ... Additional plotting arguments.
#' @return Nothing.
plot.col <- function(time, obs, obsx=NULL, pch=1, add=FALSE, typ='p', do.line=TRUE,
                     add.legend=FALSE, add.vline.at=NULL, ...){
    if (is.null(obsx)){
        x <- time
    } else {
        x <- obsx
    }
    nobs <- length(obs)
    mods <- time%%1
    cols <- season.cols(mods)
    if (!add){
        plot(x, obs, typ='n', ...)
    }
    if (!is.null(add.vline.at)){
        abline(v=add.vline.at, lty=3, col='gray')
    }
    if (typ=='p' & do.line){
        lines(x, obs, col='lightgray')
    }
    if (typ=='p'){
        pchs <- rep_len(1:5,pch)
        points(x, obs, col=1, pch=20+pchs[pch], bg=cols)
    }
    if (typ=='l'){
        qs <- unique(mods)
        qcols <- season.cols(qs)
        nintv <- length(qs)
        if (nintv <= 4){
            for (i in 1:nintv){
                inds <- which(qs[i] == mods)
                lines(x[inds], obs[inds], col=qcols[i], lty=1)
            }
        } else {
            lines(x, obs, col='lightgray')
            warning('More than four observed sub-annual time points (', nintv,
                    '), plotting only one line.')
        }
    }
    if (add.legend){
        add.col.legend()
    }
    if (!add){
        box(lwd=1.5)
    }
}


#' @name add.col.legend.hor
#' @title Add a legend explaining colors of points (horizontal orientation)
#' @return Nothing.
add.col.legend.hor <- function(){
    pusr <- par('usr')
    mods <- seq(0, 1, length=13)
    rgbcols <- season.cols(mods)
    nbar <- length(rgbcols)-1
    barwidth <- diff(pusr[1:2])
    dbw <- barwidth/nbar
    pxmax <- pusr[2]
    pymax <- pusr[4]
    barheight <- 0.05*diff(pusr[3:4])
    barx <- pxmax-barwidth
    bary <- pymax-barheight
    for (i in 1:nbar){
        xst <- barx+(i-1)*dbw
        rect(xst,bary,xst+dbw,pymax,col=rgbcols[i],lty=0)
    }
    rect(barx,bary,pxmax,pymax)
    labx <- seq(barx, barx+barwidth, length=5)
    laby <- pusr[4]-barheight
    text(labx[1:4]+dbw/2, laby, c('Jan', 'Apr', 'Jul', 'Oct'), pos=1)
}


#' @name add.col.legend
#' @title Add a legend explaining colors of points (vertical orientation)
#' @return Nothing.
add.col.legend <- function(){
    rel <- (par()$fin/par()$pin)[2]
    yfac <- 3*rel - 3
    opar <- par(xpd=TRUE)
    on.exit(par(opar))
    pusr <- par('usr')
    mods <- seq(0, 1, length=13)
    rgbcols <- season.cols(mods)
    nbar <- length(rgbcols)-1
    barwidth <- 0.05*diff(pusr[1:2])
    barheight <- 0.1*yfac*diff(pusr[3:4])
    dbh <- barheight/nbar
    pxmax <- pusr[2]
    pymax <- pusr[4]
    barx <- pxmax-barwidth
    bary <- pymax+barheight
    for (i in 1:nbar){
        #xst <- barx+(i-1)*dbw
        yst <- bary - (i-1)*dbh
        rect(barx, yst, pxmax, yst+dbh, col=rgbcols[i], lty=0)
    }
    #rect(barx, bary, pxmax, pymax)
    laby <- seq(bary, pymax, length=5)
    labx <- pxmax
    text(labx, laby[1:4], c('Jan', 'Apr', 'Jul', 'Oct'), pos=4, cex=0.8)
}

